# Results





```{r Feseq, include = FALSE, echo=FALSE}
#import sequential extraction data.
Seq_extr_data <- read_excel(here("index","data","Seq_extr_data.xlsx"))


# define detection limits as given by ICP report
Detlim_Fe_MgCl <- 0.068
Detlim_Fe_HCl <- 0.021
Detlim_Fe_CDB <- 0.1071
Detlim_Fe_HNO <- 0.035
Detlim_P_MgCl <- 0.097
Detlim_P_HCl <- 0.043
Detlim_P_CDB <- 0.0976
Detlim_P_HNO <- 0.057

# density of extractants and molar weight of Fe and P
d_MgCl <- 1.0467
d_pyroP <- 1.0402
d_HCl <- 1.0152
d_CDB <- 1.0887
d_HNO <- 1.414
mw_Fe <- 55.845
mw_P <- 30.973762


# define functions to calculate umol/g sediment from raw ICP and colourimetric data.
ppm_to_umol_p_g <- function(mol_weight, 
                            Dens, 
                            total_weight, 
                            sample_weight, 
                            Dil = 10, 
                            detlim, 
                            ppm){
  
 conc <- case_when(ppm/Dil < detlim ~ 0, 
                   T ~ ((total_weight/Dens)*ppm)/(sample_weight*mol_weight) 
                    )
 return(conc)
}

mM_to_umol_p_g<- function(  Dens, 
                            total_weight, 
                            sample_weight,
                            mM){
  
 conc <- case_when(mM < 0 ~ 0,
                   T ~ ((total_weight/Dens)*mM)/(sample_weight) )
                    
 return(conc)
}

# Transform raw data.
Seq_extr_trans <-  Seq_extr_data %>% 
  mutate(
    Location = case_when(
        str_detect(Station,"A")  ~ "A",
        str_detect(Station,"-B")  ~ "B",
        str_detect(Station,"-C")  ~ "C",
        str_detect(Station,"-D")  ~ "D",
        T ~ "blank"),
    Incubation = case_when(
        str_detect(Station, "1\\.") ~ "before",
        str_detect(Station, "3\\.")  ~ "after",
        T ~ "blank" ),
    Core = str_sub(Station, end = 7),
    Fe_MgCl_A_calc = ppm_to_umol_p_g(mol_weight = mw_Fe, 
                                  Dens = d_MgCl, 
                                  total_weight = weight_MgCl_A, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_Fe_MgCl,
                                  ppm = ICP_MgCl_A_Fe),
    Fe_MgCl_B_calc = ppm_to_umol_p_g(mol_weight = mw_Fe, 
                                  Dens = d_MgCl, 
                                  total_weight = weight_MgCl_B, 
                                  sample_weight = sample_weight_B, 
                                  detlim = Detlim_Fe_MgCl,
                                  ppm = ICP_MgCl_B_Fe),
    Fe_pyroP_calc = ppm_to_umol_p_g(mol_weight = mw_Fe, 
                                  Dens = d_pyroP,
                                  Dil = 20,
                                  total_weight = weight_pyroP, 
                                  sample_weight = sample_weight_B, 
                                  detlim = Detlim_Fe_HNO,
                                  ppm = ICP_pyroP_Fe),
    Fe_HCl_calc = ppm_to_umol_p_g(mol_weight = mw_Fe, 
                                  Dens = d_HCl, 
                                  total_weight = weight_HCl, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_Fe_HCl,
                                  ppm = ICP_HCl_Fe),
    Fetot_HCl_calc = mM_to_umol_p_g(Dens = d_HCl,
                                    total_weight = weight_HCl,
                                    sample_weight = sample_weight_A,
                                    mM = Col_HCl_Fetot),
    FeII_HCl_calc = mM_to_umol_p_g(Dens = d_HCl,
                                    total_weight = weight_HCl,
                                    sample_weight = sample_weight_A,
                                    mM = Col_HCl_FeII),
    FeIII_HCl_calc = mM_to_umol_p_g(Dens = d_HCl,
                                    total_weight = weight_HCl,
                                    sample_weight = sample_weight_A,
                                    mM = Col_HCl_FeIII),
    Fe_CDB_calc = ppm_to_umol_p_g(mol_weight = mw_Fe, 
                                  Dens = d_CDB, 
                                  total_weight = weight_CDB, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_Fe_CDB,
                                  ppm = ICP_CDB_Fe),
    Fe_HNO_calc = ppm_to_umol_p_g(mol_weight = mw_Fe, 
                                  Dens = d_HNO, 
                                  total_weight = weight_HNO, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_Fe_HNO,
                                  ppm = ICP_HNO_Fe*10),
    P_MgCl_A_calc = ppm_to_umol_p_g(mol_weight = mw_P, 
                                  Dens = d_MgCl, 
                                  total_weight = weight_MgCl_A, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_P_MgCl,
                                  ppm = ICP_MgCl_A_P),
    P_HCl_calc = ppm_to_umol_p_g(mol_weight = mw_P, 
                                  Dens = d_HCl, 
                                  total_weight = weight_HCl, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_P_HCl,
                                  ppm = ICP_HCl_P),
    P_CDB_calc = ppm_to_umol_p_g(mol_weight = mw_P, 
                                  Dens = d_CDB, 
                                  total_weight = weight_CDB, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_P_CDB,
                                  ppm = ICP_CDB_P),
    P_HNO_calc = ppm_to_umol_p_g(mol_weight = mw_P, 
                                  Dens = d_HNO, 
                                  total_weight = weight_HNO, 
                                  sample_weight = sample_weight_A, 
                                  detlim = Detlim_P_HNO,
                                  ppm = ICP_HNO_P*10)
    ) 

# Middle all duplicates
Seq_extr_dr <-Seq_extr_trans %>% 
                  filter(Incubation != "blank") %>% 
                  group_by(Station) %>% 
                  mutate(Fe_MgCl_A = mean(Fe_MgCl_A_calc),
                         Fe_MgCl_B = mean(Fe_MgCl_B_calc),
                         Fe_HCl_FeII = mean(FeII_HCl_calc),
                         Fe_HCl_FeIII = mean(FeIII_HCl_calc),
                         Fe_CDB = mean(Fe_CDB_calc),
                         Fe_HNO = mean(Fe_HNO_calc),
                         PyroP = mean(Fe_pyroP_calc),
                         Fe_HCl_ICP = mean(Fe_HCl_calc),
                         Fe_HCl_col = mean(Fetot_HCl_calc),
                         Fe_HClminPP = mean(Fetot_HCl_calc)-mean(Fe_pyroP_calc),
                         P_MgCl_A = mean(P_MgCl_A_calc),
                         P_HCl = mean(P_HCl_calc),
                         P_CDB = mean(P_CDB_calc),
                         P_HNO = mean(P_HNO_calc),
                         PFe_MgCl_A = mean(P_MgCl_A_calc)/mean(Fe_MgCl_A_calc),
                         PFe_HCl = mean(P_HCl_calc)/mean(Fetot_HCl_calc),
                         PFe_CDB = mean(P_CDB_calc)/mean(Fe_CDB_calc),
                         PFe_HNO = mean(P_HNO_calc)/mean(Fe_HNO_calc)) %>% 
                  distinct(Station, .keep_all = TRUE) %>% 
                  ungroup 


# create molten dataframes for figures 
seq_extr_A_Fe_molten <- Seq_extr_dr %>% 
                  select("depth","Location","Incubation", Fe_MgCl_A, Fe_HCl_FeII, Fe_HCl_FeIII, Fe_CDB, Fe_HNO) %>% 
                  melt(id.vars = c("depth","Location","Incubation"), variable.name = "Fraction" , na.rm = TRUE) 
                  
seq_extr_B_Fe_molten <- Seq_extr_dr %>% 
                  select("depth","Location","Incubation", Fe_MgCl_B, PyroP, Fe_HClminPP, Fe_CDB, Fe_HNO) %>% 
                  melt(id.vars = c("depth","Location","Incubation"), variable.name = "Fraction" , na.rm = TRUE) 
                  
seq_extr_A_P_molten <- Seq_extr_dr %>% 
                  select("depth","Location","Incubation", P_MgCl_A, P_HCl, P_CDB, P_HNO) %>% 
                  melt(id.vars = c("depth","Location","Incubation"), variable.name = "Fraction" , na.rm = TRUE) 

seq_extr_PFe_molten <- Seq_extr_dr %>% 
                  select("depth","Location","Incubation",  PFe_HCl, PFe_CDB, PFe_HNO) %>% 
                  melt(id.vars = c("depth","Location","Incubation"), variable.name = "Fraction" , na.rm = TRUE) 


# create sequential extraction figures
list_sq_extr_plots <-  list(seq_extr_A_Fe_molten, seq_extr_B_Fe_molten, seq_extr_A_P_molten)

for (i in 1:length(list_sq_extr_plots)) {
  
  j <- ggplot(list_sq_extr_plots[[i]], 
       aes(fill=Fraction, 
           y=value, 
           x=depth),
       scale_x_discrete(position = 'top'))+
    geom_area(
      aes(color = Fraction),
      stat = "identity", position = position_stack(reverse=TRUE))+
    geom_point(
      aes(color = Fraction),
      stat = "identity", position = position_stack(reverse=TRUE),color="black")+
    geom_line(
      aes(color = Fraction),
      stat = "identity", position = position_stack(reverse=TRUE),color="black")+
    coord_flip()+
    scale_x_reverse()+ 
    xlab("Depth (mm)")+ 
    scale_y_continuous(breaks=NULL,labels=NULL,name=NULL,sec.axis = sec_axis(~ . *1,name=expression(paste("Extracted Fe (",mu,"mol'*g DW"^-1,")"))))+
    ylab(expression(paste("Extracted Fe (",mu,"mol gDW"^-1,")")))+
    theme_classic()+
    scale_color_grey()+ 
    scale_fill_brewer(palette = "Reds",direction = -1)+
    theme(axis.title=element_text(size=28),plot.title = element_text(hjust = 0.5),
          axis.text=element_text(size=24,angle = 0, hjust = 0.5),
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          legend.title = element_text( size = 20),
          legend.text = element_text(size = 20)) +
    facet_grid(Location ~ Incubation)

ggsave(paste("seq_extr_Fe_",i,".png",sep=""), plot =j, path = path.expand(here("index","figures")),

       width =30, height = 50,units = "cm",dpi = 600)
  
}


# Create figure show P/Fe ratio
Lables = as_labeller( c(  "PFe_MgCl_A" = "MgCl", 
                          "PFe_HCl" = "HCl",
                          "PFe_CDB" = "CBD", 
                          "PFe_HNO" = "HNO[3]",
                          "after" = "After",
                          "before" = "Before") , default =  label_parsed )
PFe_profile_plots <- ggplot(transform(seq_extr_PFe_molten, Incubation = factor(Incubation, levels = c("before","after"))), mapping = aes(
                        x = value,
                        y = depth ,
                        color = Location,
                        shape = Location)
         ) +
       
       scale_color_manual( values=c("A" = "red", "B" = "blue", "C" = "red", "D" = "blue")) +
       scale_shape_manual( values=c("A" = 16, "B" = 1, "C" = 17,  "D" = 2)) +
      scale_y_reverse() +
       geom_point() + 
       geom_path() +
       facet_grid(Incubation ~ Fraction, scales = "free_y", space = "free_y", labeller = Lables) +
      
       labs(  x = expression(paste("concentration in ",mu,"mol/L")), 
              y = "Depth in cm",
              title = "pw profiles measured with IC") +
      theme_classic() +
      theme(
            axis.text.y   = element_text(size=14),
            axis.text.x   = element_text(size=14),
            axis.title.y  = element_text(size=14),
            axis.title.x  = element_text(size=14),
            strip.text.y   = element_text(size=14),
            strip.text.x   = element_text(size=14),
            panel.background = element_blank(),
            panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(),
            axis.line = element_line(colour = "black"),
            panel.border = element_rect(colour = "black", fill=NA, size=1)
            )

show(PFe_profile_plots)

ggsave("seq_extr_PFe.png", plot = PFe_profile_plots, path = path.expand(here("index","figures")),

       width =30, height = 50,units = "cm",dpi = 600)


# Create a table with P/Fe ratio statistics
PFe_range <- seq_extr_PFe_molten %>% mutate(F_range = case_when(
                      Incubation == "before" & Fraction == "PFe_HCl" & depth < 8 & (Location == "A"| Location =="C") ~ "HClshallowT",
                      Incubation == "before" & Fraction == "PFe_HCl" & depth < 8 & (Location == "B"| Location =="D") ~ "HClshallowN",
                      Incubation == "before" & Fraction == "PFe_HCl" & depth > 20 & (Location == "A"| Location =="C") ~ "HCldeepT",
                      Incubation == "before" & Fraction == "PFe_HCl" & depth > 20 & (Location == "B"| Location =="D") ~ "HCldeepN",
                      Incubation == "before" & Fraction == "PFe_CDB" & depth < 8 & (Location == "A"| Location =="C") ~ "CBDshallowT",
                      Incubation == "before" & Fraction == "PFe_CDB" & depth < 8 & (Location == "B"| Location =="D") ~ "CBDshallowN",
                      Incubation == "before" & Fraction == "PFe_CDB" & depth > 20 & (Location == "A"| Location =="C") ~ "CBDdeepT",
                      Incubation == "before" & Fraction == "PFe_CDB" & depth > 20 & (Location == "B"| Location =="D") ~ "CBDdeepN",
                      Incubation == "before" & Fraction == "PFe_HNO" & depth < 8 & (Location == "A"| Location =="C") ~ "HNOshallowT",
                      Incubation == "before" & Fraction == "PFe_HNO" & depth < 8 & (Location == "B"| Location =="D") ~ "HNOshallowN",     
                      Incubation == "before" & Fraction == "PFe_HNO" & depth > 20 & (Location == "A"| Location =="C") ~ "HNOdeepT",
                      Incubation == "before" & Fraction == "PFe_HNO" & depth > 20 & (Location == "B"| Location =="D") ~ "HNOdeepN",
                                                   T ~ "A")) 
group_by(PFe_range, F_range) %>% summarise(mean = mean(value), sd = sd(value)) %>% view

l = list("HClshallow","HCldeep","CBDshallow","CBDdeep","HNOshallow","HNOdeep")
for (i in 1:6) {
  v = 
  t.test(  pull(PFe_range[PFe_range$F_range == paste(l[i],"T", sep = ""), ], value),
  pull(PFe_range[PFe_range$F_range == paste(l[i],"N", sep = ""), ], value)
  )$p.value
  print(v)
} 



# some statistical analyses
eq <- function(x,y) {
  m <- lm(y ~ x)
  as.character(
    as.expression(
      substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2,
                list(a = format(coef(m)[1], digits = 4),
                b = format(coef(m)[2], digits = 4),
                r2 = format(summary(m)$r.squared, digits = 3)))
    )
  )
}



eqdepth <- Seq_extr_dr %>% filter(depth <= 10 & depth > 0)

loc  <-  list("A","B","C","D")
frac <- list("Fe_MgCl_A", "PyroP", "Fe_HCl_col", "Fe_CDB", "Fe_HNO")
tab <- matrix(nrow = 5, ncol = 5)
for (i in 1:4) {
for (j in 1:5) {
  

t = t.test(
  pull(eqdepth[eqdepth$Incubation == "before" & eqdepth$Location == loc[[i]],], frac[[j]]),
pull(eqdepth[eqdepth$Incubation == "after" & eqdepth$Location == loc[[i]],], frac[[j]]),
paired = TRUE)$p.value

tab[j,i] <- t
}
}
view(tab)


pyr_bp = ggplot(eqdepth,
        mapping = aes(y = Fe_HNO,
                      x = Core)) + geom_boxplot()
crys_bp = ggplot(eqdepth,
        mapping = aes(y = Fe_CDB,
                      x = Core)) + geom_boxplot()
HCl_bp = ggplot(eqdepth,
        mapping = aes(y = Fe_HCl_col,
                      x = Core)) + geom_boxplot()
org_bp = ggplot(eqdepth,
        mapping = aes(y = PyroP,
                      x = Core)) + geom_boxplot()
salt_bp = ggplot(eqdepth,
        mapping = aes(y = Fe_MgCl_A,
                      x = Core)) + geom_boxplot()
show(pyr_bp)
show(crys_bp)
show(HCl_bp)
show(org_bp)
show(salt_bp)

eqdepth %>% group_by(Core) %>% summarise(Location = first(Location), Incubation = first(Incubation), Pyrite = mean(Fe_HNO), sumPyrite = sum(Fe_HNO)) 

seq_extr_Fe <- ggplot(Seq_extr_dr, 
      mapping = aes( 
           y=Fe_HCl_ICP, 
           x=Fe_HCl_col),
       scale_x_discrete(position = 'top')) +
    geom_point(
      stat = "identity", position = position_stack(reverse=TRUE),color="black") +
    stat_smooth(method = "lm")+
    geom_text(x = 25, y = 300, label = eq(Seq_extr_dr$Fe_HCl_col, Seq_extr_dr$Fe_HCl_ICP), parse = TRUE)
show(seq_extr_Fe)
 

```

```{r swcalc, include = FALSE, echo=FALSE}

EC_A <- c(434,	449,	433)
EC_B <- c(446,	456,	451)
EC_C <- c(379,	408,	400)
EC_D <- c(392,	397,	402)
EC <- list(EC_A, EC_B, EC_C, EC_D)

for (i in 1:4) {
 m = mean(EC[[i]])
 s = sd(EC[[i]])
 print(m)
 print(s)
  
}

t.test(EC_A, EC_B)
t.test(EC_C, EC_D)
t.test(c(EC_A, EC_B),c(EC_C, EC_D))
```

* The surface water at the treated and non treated locations was similar in composition and oxic conditions at time of sampling.

* locations A and B had a significantly higher electric conductivity (438 $\mu$S and 451$\mu$S), than locations C and D (395$\mu$S and 397$\mu$S)

* This can be explained by a higher sulphate concentration, which remains relatively high in the A and B locations deeper in the sediment.

* Porewater profiles show high dissolved iron at 1 - 10 cm depth in treated cores. Non treated porewater contains very little iron.

* Phosphate concentration in porewater anticorrelates with the dissolved iron, the non treated cores have more phosphate in their porewater.

* An increase in ammonium is seen in the first 10 days in all cores. The non treated cores also show an increase in phosphate. 

* Under anoxic conditions, iron concentrations increase in the treated cores, followed by an increase in phosphate.

* After the initial increase, concentrations of NH4, Fe and P stabilize. The oxic cores show a decrease in P and NH4 levels, and an increase in nitrate concentration. In the anoxic incubations, this is followed by an increase in sulphide in the non treated cores, but not in the treated locations.

* The sequential extraction data shows that iron is much more abundant in the treated cores than in the non treated. 

* The largest fraction in the treated cores is HCl, which targets carbonates and reactive iron oxides. In the non treated cores the HCl fraction is much less and is constrained to the top few cm.

* Pyrite is the most abundand iron phase in the reference cores, and are distributed uniformely over depth. The treated cores contain less pyrite in the top 10 cm.

* The abundance of phosphate correlates with iron. The P/Fe ratio stays constant over depth, though it changes at circa 15 cm depth, and is dependant on treatment and phase. (table)

* With the exception of pyrite, all phases have decreased significantly in the top 10 cm after anoxic incubation. Pyrite increased slightly in the non treated cores, but not in the treated ones. (table)

* The layer where iron abundancy is maximal has migrated upwards after anoxic incubating. This holds also for the depth where P/Fe ratio of treated converges with the reference.



* Use tables, figures (but prefer visual presentation):

  + Tables and figures should supplement (and not duplicate) the text.

  + Tables and figures should be provided with legends.

  + _Figure \@ref(fig:graph) shows how to include and reference graphics.
    The graphic must be labelled before. Files must be in __.eps__ format. You
    can do this really easily in R Markdown with `knitr::include_graphics()`_!

  + Figures can be referenced with `\@ref(fig:<name>)`, where `<name>` is the
    name of the code chunk.

```{r graph, echo=FALSE, fig.cap="Estimated residuals from model XXX. ...", out.width = "50%"}
knitr::include_graphics(here("index","figures","graph.eps"))
```
  + Tables and graphics may appear in the text or in the appendix, especially if
  there are many simulation results tabulated, but is also depends on the study
  and number of tables resp. figures. The key graphs and tables must appear in
  the text!

```{r table, echo=FALSE}
library(tidyverse)
col_names <- c(
  "3m", "6m", "1yr", "2yr", "3yr", "5yr", "7yr", "10yr", "12yr", "15yr"
)
means     <- c(
  3.138, 3.191, 3.307, 3.544, 3.756, 4.093, 4.354, 4.621, 4.741, 4.878
)
stddev    <- c(
  0.915, 0.919, 0.935, 0.910, 0.876, 0.825, 0.803, 0.776, 0.768, 0.762
)
row_names <- c("Mean", "StD")

df <- matrix(data = c(means, stddev), nrow = 2, byrow = T)
rownames(df) <- row_names
colnames(df) <- col_names
df <- data.frame(df)
knitr::kable(
  df,
  booktabs = TRUE,
  caption = "Detailed descriptive statistics of location and dispersion for 2100 observed swap rates for the period from February 15, 1999 to March 2, 2007. Swap rates measured as 3.12 (instead of 0.0312).",
  col.names = col_names, 
  escape = FALSE
) %>%
kable_styling(latex_options = c("HOLD_position")) %>%
row_spec(2, hline_after = T)
```

* Allows the reader to judge whether the sample is biased or to evaluate 
  possible impacts of outliers, for example.

* Here tables can be easily integrated using the `kable()` function in the
  `knitr` package (with perhaps some additional help from the `kableExtra`
  package). `kable()` will automatically generate a label for the table
  environment. That way you don't have to manually enter in the table in LaTex,
  you can embed tables from R code. 

* Tables can be referenced using `\@ref(label)`, where `label` is `tab:<name>`,
  where `<name>` is the code chunk label.

* The appearance may look different to tables directly typed with LaTex, due to
  limitations in `kable()`. To compare:
    \begin{table}[ht]

    \begin{center}
        {\footnotesize
        \begin{tabular}{l|cccccccccc}
            \hline \hline
                      & 3m    & 6m    & 1yr   & 2yr   & 3yr   & 5yr   & 7yr   & 10yr  & 12yr  & 15yr   \\
            \hline
                Mean   & 3.138 & 3.191 & 3.307 & 3.544 & 3.756 & 4.093 & 4.354 & 4.621 & 4.741 & 4.878  \\
                StD    & 0.915 & 0.919 & 0.935 & 0.910 & 0.876 & 0.825 & 0.803 & 0.776 & 0.768 & 0.762  \\
            \hline \hline
        \end{tabular}}
    \end{center}
    \caption{This table was handwritten with LaTeX.}
    \label{tab:table2}
    \end{table}

* R Markdown can also supports math equations just like _LaTeX_!

  + _Equation \@ref(eq:SpecDens) represents the ACs of a stationary
    stochastic process:_
    \begin{equation}
            f_y(\lambda) = (2\pi)^{-1} \sum_{j=-\infty}^{\infty}
                           \gamma_j e^{-i\lambda j}
                         =(2\pi)^{-1}\left(\gamma_0 + 2 \sum_{j=1}^{\infty}
        \gamma_j \cos(\lambda j)\right)
                                       (\#eq:SpecDens)
    \end{equation}
    _where $i=\sqrt{-1}$ is the imaginary unit, $\lambda \in [-\pi, \pi]$ is the
    frequency and the $\gamma_j$ are the autocovariances of $y_t$._

  + Equations can be referenced with `\@ref(eq:<name>)`, where name is defined
    by adding `(\#eq:<name>)` in the line immediately before `\end{equation}`.

## Review of Results

*  Do the results support or do they contradict theory ?

*  What does the reader learn from the results?

*  Try to give an intuition for your results.

*  Provide robustness checks.

*  Compare to previous research.
